// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Coin from "./Coin.res.mjs";
import * as Text from "./Text.res.mjs";
import * as Wall from "./Wall.res.mjs";
import * as Queue from "./Queue.res.mjs";
import * as GameArea from "./GameArea.res.mjs";
import * as Constants from "./Constants.res.mjs";
import * as SnakePart from "./SnakePart.res.mjs";
import * as GameContext from "./GameContext.res.mjs";
import * as Stdlib_Array from "rescript/lib/es6/Stdlib_Array.js";

function resetGameState() {
  return {
    lastUpdate: 0.0,
    speed: Constants.initialGameSpeed,
    currentDirection: GameContext.k.Vec2.RIGHT,
    directionQueue: Queue.make(3),
    score: 0
  };
}

let directionMap = new Map([
  [
    "up",
    GameContext.k.Vec2.UP
  ],
  [
    "down",
    GameContext.k.Vec2.DOWN
  ],
  [
    "left",
    GameContext.k.Vec2.LEFT
  ],
  [
    "right",
    GameContext.k.Vec2.RIGHT
  ]
]);

function areOppositeVectors(v1, v2) {
  if (v1.x === - v2.x) {
    return v1.y === - v2.y;
  } else {
    return false;
  }
}

function gameOver(score) {
  GameContext.k.go("GameOver", score);
}

function game() {
  let gameState = resetGameState();
  Wall.make(0.0, 0.0, Constants.gameSizeF, Constants.tileSize);
  Wall.make(0.0, Constants.gameSizeF - Constants.tileSize, Constants.gameSizeF, Constants.tileSize);
  Wall.make(0.0, 0.0, Constants.tileSize, Constants.gameSizeF);
  Wall.make(Constants.gameSizeF - Constants.tileSize, 0.0, Constants.tileSize, Constants.gameSizeF);
  let gameArea = GameArea.make();
  let snakeHead = SnakePart.make(9 * Constants.tileSize, 9 * Constants.tileSize, "SnakeHead");
  let headPos = snakeHead.pos;
  let snakeTail = Stdlib_Array.fromInitializer(2, idx => SnakePart.make(headPos.x + (idx - 1 | 0) * Constants.tileSize, headPos.y, "SnakeTail"));
  let scoreText = Text.make("Score: " + gameState.score.toString(), Constants.tileSize, Constants.gameSizeF / 2, Constants.gameSizeF + Constants.tileSize);
  GameContext.k.onUpdate(() => {
    let deltaTime = GameContext.k.dt();
    gameState.lastUpdate = gameState.lastUpdate + deltaTime;
    if (gameState.lastUpdate < gameState.speed) {
      return;
    }
    let direction = Queue.dequeue(gameState.directionQueue);
    if (direction !== undefined && !areOppositeVectors(gameState.currentDirection, direction)) {
      gameState.currentDirection = direction;
    }
    let nextMove = gameState.currentDirection.scale(Constants.tileSizeVector);
    let currentPos = snakeHead.pos;
    let nextPos = currentPos.add(nextMove);
    if (gameArea.hasPoint(nextPos)) {
      snakeHead.pos = nextPos;
      Stdlib_Array.reduce(snakeTail, currentPos, (acc, tailPart) => {
        let nextTailPos = tailPart.pos;
        tailPart.pos = acc;
        return nextTailPos;
      });
    } else {
      gameOver(gameState.score);
    }
    let match = GameContext.k.get("Coin");
    if (match.length === 1) {
      let coin = match[0];
      if (coin.hasPoint(nextPos)) {
        coin.destroy();
        gameState.score = gameState.score + 1 | 0;
        Coin.make(snakeHead, snakeTail);
        scoreText.text = "Score: " + gameState.score.toString();
        snakeTail.push(SnakePart.make(currentPos.x, currentPos.y, "SnakeTail"));
        gameState.speed = gameState.speed - 0.1;
      }
      
    }
    if (snakeTail.some(tailPart => tailPart.hasPoint(nextPos))) {
      gameOver(gameState.score);
    }
    gameState.lastUpdate = 0.0;
  });
  GameContext.k.onKeyRelease(key => {
    let direction = Queue.peek(gameState.directionQueue);
    let nextDirection = direction !== undefined ? direction : gameState.currentDirection;
    let direction$1 = directionMap.get(key);
    if (direction$1 !== undefined && !areOppositeVectors(nextDirection, direction$1)) {
      return Queue.enqueue(gameState.directionQueue, direction$1);
    }
    
  });
  Coin.make(snakeHead, snakeTail);
}

function gameOver$1(score) {
  Text.make("Game Over", 30, GameContext.k.center().x, GameContext.k.center().y);
  Text.make("Score " + score.toString(), 20, GameContext.k.center().x, GameContext.k.center().y + 50);
  Text.make("(Click to play again)", 16, GameContext.k.center().x, GameContext.k.center().y + 90);
  GameContext.k.onClick(() => {
    GameContext.k.go("Game");
  });
}

GameContext.k.scene("Game", game);

GameContext.k.scene("GameOver", gameOver$1);

GameContext.k.go("Game");

export {
  resetGameState,
  directionMap,
  areOppositeVectors,
  game,
  gameOver$1 as gameOver,
}
/* directionMap Not a pure module */
